# Resample and Reorder (R&R)
Scripts to reproduce the analyses and figures of Carlson et al. "Robust detection of specific epistasis with rank-statistics".

All of the data (empirical and simulated) and associated results required to produce the figures in the manuscript are provided in this repository.

To reproduce the simulations and to re-run the analyses of simulated and empirical data with R&R and DiMSum + MoCHI (D+M), see (**4-6**).
All of these computations were performed on the Midway cluster at University of Chicago.
All of the code required to reproduce these analyses is provided in this repository (in directory *code*).
However, you will need to modify the *sbatch* scripts appropriately, i.e., change the file paths, and
install both DiMSum and MoCHI (see **5**).

# 1. Plotting the empirical figures (Figures 4-6)


**For GB1:**

1. Open and run *notebooks/gb1_figures.ipynb*. To generate pdfs set *save = True*.

*Optional:* To generate the processed read count data and distance matrix associated with the crystal structure:

1. Run *python code/parse\_gb1\_replicates.py 21 results/GB1 GB1 827*.
2. Run *python code/parse\_gb1\_pdb.py*
3. Run *python code/generate\_min\_distance\_matrix.py data/GB1/gb1\_heavy\_pos.csv gb1 data/GB1*.

**For Fos-Jun:**

1. Open and run *notebooks/fosjun\_figures\_1.ipynb*. To generate pdfs set *save = True*.
2. Open and run *notebooks/fosjun\_figures\_2.ipynb*. To generate pdfs set *save = True*.

*Optional:* To generate the processed read count data and distance matrix associated with the crystal structure:

1. Run *python code/parse\_fosjun\_trans.py 11 results/fosjun fos 325*.
2. Run *python code/parse\_fosjun\_pdb.py* and then *python code/generate\_min\_distance\_matrix.py data/fosjun/fosjun\_pos.csv fosjun data/fosjun* to generate the distance matrix.

**For PDZ3-CRIPT:**

1. Open and run *notebooks/analyze\_pdz\_both.ipynb*: To generate the PDZ3-CRIPT figures for blocks 1 and 2.

*Optional:* To generate the processed read count data and the distance matrix associated with the crystal structure:

1. Run *python code/parse\_pdz\_fuzzy\_block.py 11 20 .05 results/fuzzy 1255 block_1 1* to generate the read count data for block 1.
2. Run *python code/parse\_pdz\_fuzzy\_block.py 11 20 .05 results/fuzzy 1255 block_2 2* to generate the read count data for block 2.
3. Run *python code/parse\_pdz\_pdb.py* and then *python code/generate\_min\_distance\_matrix.py data/fuzzy/pdz\_pos.csv pdz data/fuzzy*.


## Data

Contains a folder for each of the empirical datasets, GB1 (Olson et al. 2014), Fos-Jun (Diss and Lehner, 2018), and PDZ3-CRIPT (Zarin and Lehner, 2024).

### GB1
1. *ddG\_nisthal.csv*: estimated folding energies for a large proportion of GB1 single mutants (Nisthal et al. 2020), produced by running *parse\_nisthal.py* on *nisthal\_data.csv* (4).
2. *energies.csv*: estimated folding and binding energies from Otwinowski 2018 (downloaded from https://github.com/jotwin/ProteinGthermo).
3. *GB1\_distance\_matrix.txt*: distance matrix generated by running *parse\_gb1\_pdb.py* and *generate\_distance\_matrix.py*.
4. *nisthal\_data.csv*: unformatted estimated folding energies from Nisthal et al. 2020, downloaded from protabank.org, id: gwoS2haU3. (Used to generate *ddG\_nisthal.csv*.)

### fosjun

Contains the relevant Fos-Jun DMS data from Diss and Lehner 2018.

1. *SRR5952429\_counts.tsv*, *SRR5952430\_counts.tsv*, and *SRR5952431\_counts.tsv* contain the pre-selection counts for replicates 1-3, respectively.
2. *SRR5952432\_counts.tsv*, *SRR5952433\_counts.tsv*, and *SRR5952434\_counts.tsv* contain the post-selection counts for replicates 1-3, respectively.
3. *fosjun\_distance\_matrix.txt*: distance matrix generated by running *parse\_fosjun\_pdb.py* and *generate\_distance\_matrix.py*.

These files were produced by running BRYAN SCRIPT on the raw sequencing reads downloaded from SRA LABELS.

### fuzzy

Contains the relevant PDZ3-CRIPT data from Zarin and Lehner 2024 (downloaded from https://zenodo.org/records/11048045). 

1. *pdz3b1\_short\_long\_consolidated\_wtfiltered\_fitnessreps.tsv*: fitness estimates and read counts for CRIPT mutants and block 1 of PDZ3.
2. *pdz3b2\_short\_long\_consolidated\_wtfiltered\_fitnessreps.tsv*: fitness estimates and read counts for CRIPT mutants and block 2 of PDZ3. 
3. *pdz\_distance\_matrix.txt*: distance matrix generated by running *parse\_pdz\_pdb.py* and *generate\_distance\_matrix.py*.


### pdb

Contains PDB files for each of the data sets.
 
1. 5heb.pdb (PDZ3 with CRIPT, Raman et al. 2016)
2. 1fos.pdb (Fos-Jun complex, Glover and Harrison 1995)
3. 2j52.pdb (GB1, Wilton et al. 2007)


# 2. Plotting the simulation figures (Figure 3)

All of the simulated data necessary to generate the simulation figures are located in the directory
*simulations*. Alternatively, one can reproduce the simulated data by running the scripts
outlined in (**4. Running R&R on simulated data**).

All plots based on the simulations in the main text and supplement can be generated by running the following jupyter notebook, located in the *notebooks* folder:

1. *notebooks/evaluate\_simulations.ipynb*: To generate all components of the simulation figures.
2. *notebooks/three\_state\_simulation\_figures.ipynb*: To generate the figures associated with the three-state GB1-like figures.

### Simulated data

All located in *simulations/*:

1. *111*: Equal cell counts + uniform lambdas.
2. *222*: Equal cell counts reduced by a factor of 10 relative to *111* + uniform lambda.
3. *333*: Variable cell counts + uniform lambdas.
4. *444*: Equal cell counts + uniform lambda + non-specific binding (delta = .0007).
5. *777*: GB1-like + high but variable cell counts.
	- *mochi_sigmoid.txt*: D+M results.*
6. *888*: GB1-like + low and variable cell counts.
	- *mochi_sigmoid.txt*: D+M results.*
7. *threestate*: GB1-like three-state simulations without SE.

\* These files contain the results of applying D+M to the simulated data under the assumption that the nonlinearity is a sum of sigmoid functions. To reproduce these files, see (**5. Running DiMSum and MoCHI**).


# 3. Plotting the expository figures (Figures 1 and 2)

All plots in the main text and supplement can be generated by running the following jupyter notebooks, located in the *notebooks* folder:

1. *notebooks/figure\_components\_1\_and\_2.ipynb*: To generate the components of Figures 1 and 2.

The data required to produce these figures is located in *simulations/999/*.


# 4. Running R&R

## Applying R&R to simulated data

The following sbatch scripts were used to simulate data under six scenarios and to apply R&R on these data sets. You will need to configure the sbatch scripts to suit your needs. They are in the same order as above (**Simulated data**).

1. *simulate\_uniform.sbatch*
2. *simulate\_uniform\_1b.sbatch*
3. *simulate\_uniform\_ns.sbatch*
4. *simulate\_uniform\_variation.sbatch*
5. *simulate\_gb1\_high.sbatch*
6. *simulate\_gb1\_low.sbatch*

In addition, we simulated GB1-like data under a three-state model:

1. *simulate\_three\_state.sbatch*


## Applying R&R to empirical datasets

The following sbatch scripts were used to apply R&R to three empirical data sets: Fos-Jun, PDZ3-CRIPT, and GB1. You will need to configure the sbatch scripts to suit your needs.

1. *estimate_fosjun_trans.sbatch*
2. *estimate_pdz_block_1.sbatch* and *estimate_pdz_block_2.sbatch*
3. *estimate_gb1.sbatch*


# 5. Running DiMSum + MoCHI

Both of these software packages need to be installed:

1. DiMSum (Faure et al. 2020) can be installed via conda (see https://github.com/lehner-lab/DiMSum.git).
2. MoCHI (Faure and Lehner 2024) can also be installed via conda (see https://github.com/lehner-lab/MoCHI.git).

For simplicity, I created separate conda environments for both packages.

## Applying D+M to simulated data

We modeled the nonlinearity as a sum of sigmoids "SumOfSigmoids".
The two design files for DiMSum and MoCHI are in the *simulations/777* and *simulations/888* folders.

1. *experimentDesign_sims.txt*: Dummy file to run DiMSum.
2. *model_design_sigmoid.txt*: Model design file for MoCHI with nonlinearity specified as a sum of sigmoids ("SumOfSigmoids").

**To run DiMSum:**

1. *sbatch ./run_dimsum_sims_high.sbatch*: Runs DiMSum on the GB1-like high simulation.
2. *sbatch ./run_dimsum_sims_low.sbatch*: Runs DiMSum on the GB1-like low simulation.

**To run MoCHI:**

1. *sbatch ./run_mochi_sims_high.sbatch*: Runs DiMSum on the GB1-like high simulation.
2. *sbatch ./run_mochi_sims_low.sbatch*: Runs DiMSum on the GB1-like low simulation.

## Applying D+M to GB1

We fit two-state and three-state thermodynamic models to the GB1 data.

**Design files:**

1. *experimentDesign\_GB1.txt*: Dummy file to run DiMSum.
2. *model\_design\_twostate.txt*: Model design file for MoCHI with nonlinearity specified as a **two-state** thermodynamic model ("TwoStateFractionFolded").
3. *model\_design.txt*: Model design file for MoCHI with nonlinearity specified as a **three-state** thermodynamic model ("ThreeStateFractionBound").

**To run D+M:**

1. *run\_dimsum\_gb1.sbatch*: Processes GB1 data with DiMSum.
2. *run\_mochi\_gb1.sbatch*: Fits both two and three-state models with MoCHI.

## Applying D+M to Fos-Jun

**Design files:**

1. *experimentDesign\_fosjun\_#.txt*: Dummy files to run DiMSum on each replicate # separately.
2. *experimentDesign\_fosjun\_all.txt*: Dummy file to run DiMSum on all replicates together.
3. *model\_design\_#.txt*: Model design file for MoCHI with nonlinearity specified as a sum of sigmoids ("SumOfSigmoids") for each replicate #.
4. *model_design_all.txt*: Model design file for MoCHI with nonlinearity specified as a sum of sigmoids ("SumOfSigmoids") for the fitness estimates from the combined replicates.

**To run D+M:**

1. *run_dimsum_fosjun_reps.sbatch*: Processes each replicate separately with DiMSum.
2. *run_dimsum_fosjun.sbatch*: Processes all replicates together with DiMSum.
2. *run_mochi_fosjun_reps.sbatch*: Fits ...
	sbatch --export=REP=0,RSEED=327 run_mochi_rep.sbatch